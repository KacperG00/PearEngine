#include "spritesheet.h"

#include "../../string_constants.h"
#include "../../Utilities/string_manipulations.h"

#include <iostream>
#include <fstream>
#include <string>

namespace pear { namespace graphics {
	
	SpriteSheet::SpriteSheet(const glm::vec4& pos_and_dim, const char* texture_name, float depth)
		: Renderable2D( RenderableType::SPRITESHEET, pos_and_dim, texture_name, depth ),
		texCoordsModifier( new glm::vec4(0.0f,0.0f,1.0f,1.0f) ),
		spriteSheetID( Renderable2D::renderableCount )
	{
		countTexCoordsModifiers( texture_name );
	}
	
	SpriteSheet::~SpriteSheet()
	{
	}
	
	void SpriteSheet::countTexCoordsModifiers( const char* filename )
	{
		readSPFile(filename);
	}
	
	void SpriteSheet::readSPFile( const char* filename )
	{
		
	}
	
	std::vector<glm::vec4> SpriteSheet::setUpAnimationData( const char* filename, const char* animationName )
	{
		bool success = false;
		
		std::vector<glm::vec4> rVector;
		
		const char* path = std::string(std::string(paths_from_build::TEXTURES) + filename).c_str();
		path = utils::changeFileExtention( path, "sp" );
		std::ifstream file( path );
		if( file.fail() )
		{
			std::cout << "Failed to open " << path << std::endl;
		}
		else
		{
			std::string currLine = "";
			
			bool animationBound = false;
			
			while( std::getline( file, currLine ) )
			{
				currLine += '\n';
				
				if( animationBound )
				{
					glm::vec4 positions;
					
					bool endOfLineFound = false;
					unsigned int commaPos = 0;
					
					unsigned int countOfNumbers = 0;
					
					int i = 0;
					while( !endOfLineFound )
					{
						if( currLine[i] == ',' || currLine[i] == '\n' )
						{
							std::string fnumber = "";
							for( int j = commaPos; j < i; j++ )
							{
								fnumber += currLine[j];
							}
							
							// traslating string to float and packing them to glm::vec4 positions
							switch( countOfNumbers % 4 )
							{
								case 0:
								{
									countOfNumbers++;
									positions.x = std::stof( fnumber );
								} break;
								case 1:
								{
									countOfNumbers++;
									positions.y = std::stof( fnumber );
								} break;
								case 2:
								{
									countOfNumbers++;
									positions.z = std::stof( fnumber );
								} break;
								case 3:
								{
									countOfNumbers = 0;
									positions.w = std::stof( fnumber );
									rVector.push_back( glm::vec4( positions.x, positions.y, positions.z, positions.w ) );
								} break;
							}
							
							commaPos = i + 1;
							
							if( currLine[i] == '\n' )
								endOfLineFound = true;
						}
						
						if( currLine[i] == ';' )
						{
							animationBound = false;
							endOfLineFound = true;
						}
						
						i++;
					}
				}
				
				if( utils::findWord( currLine.c_str(), std::string( std::string( "animation " ) + animationName + ":\n" ).c_str() ) >= 0 )
				{
					animationBound = true;
					success = true;
				}
			}
		}
		file.close();
		
		if( !success )
			std::cout << "Animation " << animationName << " is not found\n";
		
		return rVector;
	}
	
} }
